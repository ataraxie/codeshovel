diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java
index 6cad4a047..cd7006e77 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java
@@ -47,84 +47,94 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * </pre>
  * <p>
  * An example of how to configure the check so that it accepts methods with at
  * most 60 lines is:
  * </p>
  * <pre>
  * &lt;module name="MethodLength"&gt;
  *    &lt;property name="max" value="60"/&gt;
  * &lt;/module&gt;
  * </pre>
  * @author Lars KÃ¼hne
  */
 public class MethodLengthCheck extends Check {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "maxLen.method";
 
     /** Default maximum number of lines. */
     private static final int DEFAULT_MAX_LINES = 150;
 
     /** Whether to ignore empty lines and single line comments. */
     private boolean countEmpty = true;
 
     /** The maximum number of lines. */
     private int max = DEFAULT_MAX_LINES;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.METHOD_DEF, TokenTypes.CTOR_DEF};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final DetailAST openingBrace = ast.findFirstToken(TokenTypes.SLIST);
         if (openingBrace != null) {
             final DetailAST closingBrace =
                 openingBrace.findFirstToken(TokenTypes.RCURLY);
-            int length =
-                closingBrace.getLineNo() - openingBrace.getLineNo() + 1;
-
-            if (!countEmpty) {
-                final FileContents contents = getFileContents();
-                final int lastLine = closingBrace.getLineNo();
-                for (int i = openingBrace.getLineNo() - 1; i < lastLine; i++) {
-                    if (contents.lineIsBlank(i) || contents.lineIsComment(i)) {
-                        length--;
-                    }
-                }
-            }
+            final int length = getLengthOfBlock(openingBrace, closingBrace);
             if (length > max) {
                 log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY,
                         length, max);
             }
         }
     }
 
+    /**
+     * Returns length of code only without comments and blank lines.
+     * @param openingBrace block opening brace
+     * @param closingBrace block closing brace
+     * @return number of lines with code for current block
+     */
+    private int getLengthOfBlock(DetailAST openingBrace, DetailAST closingBrace) {
+        int length = closingBrace.getLineNo() - openingBrace.getLineNo() + 1;
+
+        if (!countEmpty) {
+            final FileContents contents = getFileContents();
+            final int lastLine = closingBrace.getLineNo();
+            for (int i = openingBrace.getLineNo() - 1; i < lastLine; i++) {
+                if (contents.lineIsBlank(i) || contents.lineIsComment(i)) {
+                    length--;
+                }
+            }
+        }
+        return length;
+    }
+
     /**
      * @param length the maximum length of a method.
      */
     public void setMax(int length) {
         max = length;
     }
 
     /**
      * @param countEmpty whether to count empty and single line comments
      *     of the form //.
      */
     public void setCountEmpty(boolean countEmpty) {
         this.countEmpty = countEmpty;
     }
 }
